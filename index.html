<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube Auto Manager PRO - Production</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <style>
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
        .animate-pulse { animation: pulse 2s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .tab { cursor: pointer; padding: 8px 16px; border-bottom: 2px solid transparent; transition: all 0.2s; }
        .tab.active { border-bottom-color: #dc2626; color: #dc2626; font-weight: bold; }
        .tab:hover { background: #f3f4f6; }
        .ai-badge { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            animation: shimmer 2s infinite;
        }
        @keyframes shimmer { 0%, 100% { opacity: 1; } 50% { opacity: 0.8; } }
        .pro-badge {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // ========================================
        // YouTube API ì„¤ì •
        // ========================================
        const YOUTUBE_CLIENT_ID = '209770688632-orkjj4ga1n6eotqv5966m7nrkvkpijdf.apps.googleusercontent.com'; // ì—¬ê¸°ì— í´ë¼ì´ì–¸íŠ¸ ID ì…ë ¥!
        const YOUTUBE_API_KEY = 'AIzaSyDuaNXVMqAUVsuw2zjXANidGo0iK1rPfMU'; // ì—¬ê¸°ì— API í‚¤ ì…ë ¥!
        const YOUTUBE_DISCOVERY_DOCS = ['https://www.googleapis.com/discovery/v1/apis/youtube/v3/rest'];
        const YOUTUBE_SCOPES = 'https://www.googleapis.com/auth/youtube.force-ssl';

        function YouTubeAutoManager() {
          const [isAuthenticated, setIsAuthenticated] = useState(false);
          const [user, setUser] = useState(null);
          const [currentTab, setCurrentTab] = useState('home');
          const [channels, setChannels] = useState([]);
          const [hashtagRules, setHashtagRules] = useState([]);
          const [keywordRules, setKeywordRules] = useState([]);
          const [comments, setComments] = useState([]);
          const [newVideos, setNewVideos] = useState([]);
          const [logs, setLogs] = useState([]);
          const [isMonitoring, setIsMonitoring] = useState(false);
          const [apiUsage, setApiUsage] = useState({ youtube: 0, ai: 0, saved: 0 });
          const [checkInterval, setCheckInterval] = useState(5);
          const [autoCommentEnabled, setAutoCommentEnabled] = useState(true);
          const [hashtagEnabled, setHashtagEnabled] = useState(true);
          const [keywordEnabled, setKeywordEnabled] = useState(false);
          const [keywordMaxResults, setKeywordMaxResults] = useState(3);
          
          // ğŸ¤– AI ëŒ“ê¸€ ì„¤ì •
          const [aiCommentEnabled, setAiCommentEnabled] = useState(false);
          const [aiDemoMode, setAiDemoMode] = useState(true);
          const [anthropicApiKey, setAnthropicApiKey] = useState('');
          const [aiCommentStyle, setAiCommentStyle] = useState('friendly');
          const [aiEmojiUsage, setAiEmojiUsage] = useState('moderate');
          const [aiCommentLength, setAiCommentLength] = useState('medium');
          const [aiAnalyzeImage, setAiAnalyzeImage] = useState(true);
          const [aiTrendAware, setAiTrendAware] = useState(true);
          const [aiCustomPrompt, setAiCustomPrompt] = useState('');
          
          // ğŸš€ ìµœì í™” ì„¤ì •
          const [cacheEnabled, setCacheEnabled] = useState(true);
          const [incrementalEnabled, setIncrementalEnabled] = useState(true);
          const [headCheckEnabled, setHeadCheckEnabled] = useState(true);
          const [cacheTTL, setCacheTTL] = useState({
            channelInfo: 24 * 60,
            videoList: 5,
            videoDetails: 60
          });
          const [headCheckInterval, setHeadCheckInterval] = useState(5);
          const [fullSearchMaxInterval, setFullSearchMaxInterval] = useState(60);
          
          const cacheRef = useRef({
            channels: {},
            videos: {},
            stats: { hits: 0, misses: 0, requests: 0 }
          });
          
          const incrementalStateRef = useRef({});
          const monitoringRef = useRef(null);
          const gapiRef = useRef(null);

          // ========================================
          // ì´ˆê¸°í™” & ì €ì¥
          // ========================================
          useEffect(() => {
            const saved = localStorage.getItem('yt_data_production_v1');
            if (saved) {
              const data = JSON.parse(saved);
              setChannels(data.channels || []);
              setHashtagRules(data.hashtagRules || []);
              setKeywordRules(data.keywordRules || []);
              setComments(data.comments || []);
              setLogs(data.logs || []);
              setApiUsage(data.apiUsage || { youtube: 0, ai: 0, saved: 0 });
              if (data.incrementalState) incrementalStateRef.current = data.incrementalState;
              if (data.cacheEnabled !== undefined) setCacheEnabled(data.cacheEnabled);
              if (data.incrementalEnabled !== undefined) setIncrementalEnabled(data.incrementalEnabled);
              if (data.headCheckEnabled !== undefined) setHeadCheckEnabled(data.headCheckEnabled);
              if (data.aiCommentEnabled !== undefined) setAiCommentEnabled(data.aiCommentEnabled);
              if (data.aiDemoMode !== undefined) setAiDemoMode(data.aiDemoMode);
              if (data.anthropicApiKey) setAnthropicApiKey(data.anthropicApiKey);
              if (data.aiCommentStyle) setAiCommentStyle(data.aiCommentStyle);
              if (data.aiEmojiUsage) setAiEmojiUsage(data.aiEmojiUsage);
              if (data.aiCommentLength) setAiCommentLength(data.aiCommentLength);
              if (data.cacheTTL) setCacheTTL(data.cacheTTL);
            }
            
            // YouTube API ì´ˆê¸°í™”
            initYouTubeAPI();
          }, []);

          useEffect(() => {
            localStorage.setItem('yt_data_production_v1', JSON.stringify({ 
              channels, hashtagRules, keywordRules, comments, logs, apiUsage,
              incrementalState: incrementalStateRef.current,
              cacheEnabled, incrementalEnabled, headCheckEnabled,
              aiCommentEnabled, aiDemoMode, anthropicApiKey,
              aiCommentStyle, aiEmojiUsage, aiCommentLength, cacheTTL
            }));
          }, [channels, hashtagRules, keywordRules, comments, logs, apiUsage, 
              cacheEnabled, incrementalEnabled, headCheckEnabled,
              aiCommentEnabled, aiDemoMode, anthropicApiKey,
              aiCommentStyle, aiEmojiUsage, aiCommentLength, cacheTTL]);

          // ========================================
          // YouTube API ì´ˆê¸°í™”
          // ========================================
          const initYouTubeAPI = () => {
            if (YOUTUBE_CLIENT_ID === 'YOUR_YOUTUBE_CLIENT_ID_HERE') {
              addLog('âš ï¸ YouTube API ì„¤ì • í•„ìš”! ì½”ë“œì— Client IDë¥¼ ì…ë ¥í•˜ì„¸ìš”.', 'warning');
              return;
            }
            
            gapi.load('client:auth2', () => {
              gapi.client.init({
                apiKey: YOUTUBE_API_KEY,
                clientId: YOUTUBE_CLIENT_ID,
                discoveryDocs: YOUTUBE_DISCOVERY_DOCS,
                scope: YOUTUBE_SCOPES
              }).then(() => {
                gapiRef.current = gapi;
                addLog('âœ… YouTube API ì´ˆê¸°í™” ì™„ë£Œ', 'success');
                
                // ì´ë¯¸ ë¡œê·¸ì¸ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
                const authInstance = gapi.auth2.getAuthInstance();
                if (authInstance.isSignedIn.get()) {
                  handleAuthSuccess();
                }
              }).catch(error => {
                addLog(`âŒ YouTube API ì´ˆê¸°í™” ì‹¤íŒ¨: ${error.message}`, 'error');
              });
            });
          };

          // ========================================
          // ë¡œê·¸ì¸ & ë¡œê·¸ì•„ì›ƒ
          // ========================================
          const handleLogin = async () => {
            if (YOUTUBE_CLIENT_ID === 'YOUR_YOUTUBE_CLIENT_ID_HERE') {
              alert('YouTube API ì„¤ì •ì´ í•„ìš”í•©ë‹ˆë‹¤!\n\nì½”ë“œ ìƒë‹¨ì˜ YOUTUBE_CLIENT_IDì™€ YOUTUBE_API_KEYë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.\n\nì„¤ì • ë°©ë²•:\n1. https://console.cloud.google.com ì ‘ì†\n2. YouTube Data API v3 í™œì„±í™”\n3. OAuth 2.0 í´ë¼ì´ì–¸íŠ¸ ID ìƒì„±');
              return;
            }
            
            try {
              const authInstance = gapi.auth2.getAuthInstance();
              await authInstance.signIn();
              handleAuthSuccess();
            } catch (error) {
              addLog(`âŒ ë¡œê·¸ì¸ ì‹¤íŒ¨: ${error.message}`, 'error');
            }
          };

          const handleAuthSuccess = () => {
            const authInstance = gapi.auth2.getAuthInstance();
            const profile = authInstance.currentUser.get().getBasicProfile();
            
            setIsAuthenticated(true);
            setUser({
              name: profile.getName(),
              email: profile.getEmail(),
              image: profile.getImageUrl()
            });
            addLog(`âœ… ${profile.getName()}ë‹˜ ë¡œê·¸ì¸ ì„±ê³µ!`, 'success');
          };

          const handleLogout = () => {
            stopMonitoring();
            gapi.auth2.getAuthInstance().signOut();
            setIsAuthenticated(false);
            setUser(null);
            addLog('ë¡œê·¸ì•„ì›ƒ', 'info');
          };

          const addLog = (msg, type = 'info') => {
            setLogs(prev => [{ id: Date.now(), msg, type, time: new Date().toLocaleTimeString() }, ...prev].slice(0, 100));
          };

          const trackAPIUsage = (youtube = 0, ai = 0, saved = 0) => {
            setApiUsage(prev => ({
              youtube: prev.youtube + youtube,
              ai: prev.ai + ai,
              saved: prev.saved + saved
            }));
          };

          // ========================================
          // ìºì‹± ì‹œìŠ¤í…œ
          // ========================================
          const getCached = (key, type) => {
            if (!cacheEnabled) {
              cacheRef.current.stats.requests++;
              return null;
            }
            
            cacheRef.current.stats.requests++;
            const cache = cacheRef.current[type];
            if (!cache || !cache[key]) {
              cacheRef.current.stats.misses++;
              return null;
            }
            
            const ttlMinutes = cacheTTL[type === 'channels' ? 'channelInfo' : type === 'videos' ? 'videoList' : 'videoDetails'];
            const age = Date.now() - cache[key].timestamp;
            
            if (age > ttlMinutes * 60 * 1000) {
              delete cache[key];
              cacheRef.current.stats.misses++;
              return null;
            }
            
            cacheRef.current.stats.hits++;
            return cache[key].data;
          };

          const setCache = (key, type, data) => {
            if (!cacheEnabled) return;
            
            if (!cacheRef.current[type]) {
              cacheRef.current[type] = {};
            }
            
            cacheRef.current[type][key] = {
              data: data,
              timestamp: Date.now(),
              etag: data.etag || `etag_${Date.now()}`,
              lastModified: new Date().toISOString()
            };
          };

          const clearCache = () => {
            if (confirm('ìºì‹œë¥¼ ëª¨ë‘ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
              cacheRef.current = {
                channels: {},
                videos: {},
                stats: { hits: 0, misses: 0, requests: 0 }
              };
              addLog('ğŸ—‘ï¸ ìºì‹œ ì´ˆê¸°í™” ì™„ë£Œ', 'info');
            }
          };

          const resetIncrementalState = () => {
            if (confirm('ì¦ë¶„ ì²´í¬ ìƒíƒœë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
              incrementalStateRef.current = {};
              addLog('ğŸ”„ ì¦ë¶„ ìƒíƒœ ì´ˆê¸°í™” ì™„ë£Œ', 'info');
            }
          };

          const getCacheStats = () => {
            const stats = cacheRef.current.stats;
            const total = stats.requests;
            const hitRate = total > 0 ? ((stats.hits / total) * 100).toFixed(1) : 0;
            return { ...stats, total, hitRate };
          };

          // ========================================
          // HEAD ì²´í¬ ì‹œìŠ¤í…œ
          // ========================================
          const headCheck = async (channel) => {
            if (!headCheckEnabled || !incrementalEnabled) {
              return { hasNew: true, apiCost: 0, method: 'FULL' };
            }
            
            const state = incrementalStateRef.current[channel.id] || {
              lastCheck: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),
              latestVideoId: null,
              lastFullSearch: 0,
              consecutiveNoChange: 0
            };
            
            const timeSinceLastFull = Date.now() - state.lastFullSearch;
            const shouldForceFullCheck = timeSinceLastFull > fullSearchMaxInterval * 60 * 1000;
            
            if (shouldForceFullCheck) {
              state.lastFullSearch = Date.now();
              incrementalStateRef.current[channel.id] = state;
              return { hasNew: true, apiCost: 1, method: 'FORCED_FULL' };
            }
            
            try {
              const response = await gapi.client.youtube.search.list({
                part: 'snippet',
                channelId: channel.channelId,
                order: 'date',
                maxResults: 1,
                type: 'video'
              });
              
              trackAPIUsage(1);
              
              if (response.result.items.length > 0) {
                const latestVideo = response.result.items[0];
                const hasNew = !state.latestVideoId || latestVideo.id.videoId !== state.latestVideoId;
                
                if (hasNew) {
                  state.latestVideoId = latestVideo.id.videoId;
                  state.lastFullSearch = Date.now();
                  state.consecutiveNoChange = 0;
                } else {
                  state.consecutiveNoChange++;
                }
                
                state.lastCheck = new Date().toISOString();
                incrementalStateRef.current[channel.id] = state;
                
                return { hasNew, apiCost: 1, method: 'HEAD', consecutiveNoChange: state.consecutiveNoChange };
              }
              
              return { hasNew: false, apiCost: 1, method: 'HEAD' };
            } catch (error) {
              addLog(`âŒ HEAD ì²´í¬ ì‹¤íŒ¨: ${error.message}`, 'error');
              return { hasNew: true, apiCost: 1, method: 'ERROR_FALLBACK' };
            }
          };

          const performIncrementalCheck = async (channel) => {
            if (!incrementalEnabled) {
              return { hasNew: true, apiCost: 0 };
            }
            
            const state = incrementalStateRef.current[channel.id];
            if (!state || !state.latestVideoId) {
              return { hasNew: true, apiCost: 0 };
            }
            
            const cacheKey = `${channel.id}_videos`;
            const cached = cacheRef.current.videos?.[cacheKey];
            
            if (cached && cached.etag) {
              try {
                const response = await gapi.client.youtube.search.list({
                  part: 'snippet',
                  channelId: channel.channelId,
                  order: 'date',
                  maxResults: 5,
                  type: 'video',
                  publishedAfter: state.lastCheck
                });
                
                trackAPIUsage(1);
                
                if (!response.result.items || response.result.items.length === 0) {
                  return { hasNew: false, apiCost: 1, method: '304_NOT_MODIFIED' };
                }
                
                return { hasNew: true, apiCost: 1, method: 'INCREMENTAL', newVideos: response.result.items };
              } catch (error) {
                return { hasNew: true, apiCost: 1, method: 'ERROR' };
              }
            }
            
            return { hasNew: true, apiCost: 0, method: 'CACHE_MISS' };
          };

          // ========================================
          // AI ëŒ“ê¸€ ìƒì„±
          // ========================================
          // AI ëŒ“ê¸€ ìƒì„± - ë°ëª¨ ëª¨ë“œ
          const generateAICommentDemo = (videoData) => {
            const { title, hashtags = [] } = videoData;
            
            const templates = {
              friendly: {
                short: [
                  `"${title}" ì •ë§ ë©‹ì§€ë„¤ìš”! ğŸ˜Š`,
                  `ì™€ ì´ê±° ì™„ì „ ì œ ìŠ¤íƒ€ì¼ì´ì—ìš” ğŸ‘`,
                  `ì¢‹ì€ ì˜ìƒ ê°ì‚¬í•©ë‹ˆë‹¤!`,
                  `ëŒ€ë°•!! ê¸°ë‹¤ë¦¬ë˜ ì˜ìƒì´ì—ìš” âš½`
                ],
                medium: [
                  `"${title}" ì˜ìƒ ì˜ ë´¤ìŠµë‹ˆë‹¤! ì •ë§ ìœ ìµí•œ ë‚´ìš©ì´ë„¤ìš”. ë‹¤ìŒ ì˜ìƒë„ ê¸°ëŒ€í• ê²Œìš”! ğŸ˜Š`,
                  `ì´ëŸ° ì½˜í…ì¸  ì°¾ê³  ìˆì—ˆì–´ìš”! êµ¬ë…í•˜ê³  ê°‘ë‹ˆë‹¤. ì•ìœ¼ë¡œë„ ì¢‹ì€ ì˜ìƒ ë¶€íƒë“œë ¤ìš”! ğŸ‰`,
                  `ì™„ì „ ì œê°€ ê¶ê¸ˆí–ˆë˜ ë‚´ìš©ì´ì—ìš”! ì„¤ëª…ì´ ì •ë§ ì‰½ê³  ëª…í™•í•´ì„œ ì´í•´ê°€ ì˜ ëìŠµë‹ˆë‹¤ ğŸ‘`
                ],
                long: [
                  `"${title}" ì˜ìƒ ì •ë§ ì˜ ë´¤ìŠµë‹ˆë‹¤! ìš”ì¦˜ ì´ëŸ° ì£¼ì œì— ê´€ì‹¬ì´ ë§ì•˜ëŠ”ë° ë”± ì œê°€ ì°¾ë˜ ë‚´ìš©ì´ë„¤ìš”. ì„¤ëª…ë„ ì´í•´í•˜ê¸° ì‰½ê²Œ ì˜ í•´ì£¼ì…”ì„œ ê°ì‚¬í•©ë‹ˆë‹¤. ë‹¤ìŒ ì˜ìƒë„ ê¸°ëŒ€í•˜ë©´ì„œ êµ¬ë… ëˆ„ë¥´ê³  ê°‘ë‹ˆë‹¤! ğŸ˜ŠğŸ‘`,
                  `ìš°ì™€ ì´ ì˜ìƒ ì •ë§ í€„ë¦¬í‹°ê°€ ë†’ë„¤ìš”! ${hashtags.length > 0 ? hashtags.map(t => '#' + t).join(' ') + ' ê´€ë ¨í•´ì„œ ' : ''}ê¶ê¸ˆí–ˆë˜ ì ì´ ë§ì•˜ëŠ”ë° ë•ë¶„ì— ë§ì´ ë°°ì› ìŠµë‹ˆë‹¤. ì•ìœ¼ë¡œë„ ì´ëŸ° ìœ ìµí•œ ì½˜í…ì¸  ë§ì´ ì˜¬ë ¤ì£¼ì„¸ìš”! ğŸ”¥âœ¨`
                ]
              },
              formal: {
                short: [
                  `ìœ ìµí•œ ì •ë³´ ê°ì‚¬í•©ë‹ˆë‹¤.`,
                  `ì¢‹ì€ ì˜ìƒ ì˜ ì‹œì²­í–ˆìŠµë‹ˆë‹¤.`,
                  `ì „ë¬¸ì ì¸ ë‚´ìš© ê°ì‚¬ë“œë¦½ë‹ˆë‹¤.`
                ],
                medium: [
                  `"${title}" ê´€ë ¨í•˜ì—¬ ë§ì€ ë„ì›€ì´ ë˜ì—ˆìŠµë‹ˆë‹¤. ê°ì‚¬í•©ë‹ˆë‹¤.`,
                  `ì „ë¬¸ì ì¸ ë‚´ìš©ì„ ì•Œê¸° ì‰½ê²Œ ì„¤ëª…í•´ì£¼ì…”ì„œ ê°ì‚¬í•©ë‹ˆë‹¤. êµ¬ë…í•˜ê² ìŠµë‹ˆë‹¤.`,
                  `ì²´ê³„ì ì¸ ì„¤ëª… ë•ë¶„ì— ì´í•´ê°€ ì˜ ë˜ì—ˆìŠµë‹ˆë‹¤. ì¢‹ì€ ì˜ìƒ ê°ì‚¬ë“œë¦½ë‹ˆë‹¤.`
                ],
                long: [
                  `"${title}" ì˜ìƒ ì˜ ì‹œì²­í–ˆìŠµë‹ˆë‹¤. ì²´ê³„ì ì¸ ì„¤ëª…ê³¼ ì „ë¬¸ì ì¸ ë‚´ìš© êµ¬ì„±ì´ ì¸ìƒ ê¹Šì—ˆìŠµë‹ˆë‹¤. ì•ìœ¼ë¡œë„ ì´ëŸ¬í•œ ì–‘ì§ˆì˜ ì½˜í…ì¸  ë¶€íƒë“œë¦½ë‹ˆë‹¤. ê°ì‚¬í•©ë‹ˆë‹¤.`,
                  `${hashtags.length > 0 ? hashtags.map(t => '#' + t).join(' ') + 'ì— ëŒ€í•´ ' : ''}ìƒì„¸í•˜ê³  ì „ë¬¸ì ì¸ ë‚´ìš©ì„ ì œê³µí•´ì£¼ì…”ì„œ ê°ì‚¬í•©ë‹ˆë‹¤. ì‹¤ë¬´ì— ë§ì€ ë„ì›€ì´ ë  ê²ƒ ê°™ìŠµë‹ˆë‹¤. êµ¬ë…í•˜ê³  ë‹¤ìŒ ì˜ìƒë„ ê¸°ëŒ€í•˜ê² ìŠµë‹ˆë‹¤.`
                ]
              },
              humorous: {
                short: [
                  `ã…‹ã…‹ã…‹ã…‹ ì´ê±° ë­ì•¼ ê°œì›ƒê¸°ë„¤ ğŸ¤£`,
                  `ì•„ ì§„ì§œ ë¯¸ì³¤ë‹¤ ã…‹ã…‹ã…‹ ğŸ‘âœ¨`,
                  `ëŒ€ë°• ã…‹ã…‹ã…‹ ì™„ì „ í‚¹ë°›ë„¤ ğŸ˜‚`
                ],
                medium: [
                  `ã…‹ã…‹ã…‹ "${title}" ì œëª©ë¶€í„° ì›ƒê¸°ë„¤ìš” ğŸ˜‚ ì˜ìƒë„ ì¬ë°Œê²Œ ì˜ ë´¤ìŠµë‹ˆë‹¤! êµ¬ë…ë°•ê³  ê°‘ë‹ˆë‹¤ ğŸ‰`,
                  `ì•„ë‹ˆ ã…‹ã…‹ã…‹ ì´ê²Œ ë¬´ìŠ¨ ì¼ì´ì•¼ ğŸ¤£ ëª‡ ë²ˆì§¸ ë³´ëŠ”ë° ë§¤ë²ˆ ì›ƒê²¨ìš” ì•Œê³ ë¦¬ì¦˜ ê°ì‚¬í•©ë‹ˆë‹¤ ğŸ‘`,
                  `ì™€ ì§„ì§œ ì„¼ìŠ¤ ì˜¤ì§„ë‹¤ ã…‹ã…‹ã…‹ ì´ëŸ° ê±° ë„ˆë¬´ ì¢‹ì•„ìš”! ë‹¤ìŒ í¸ ì–¸ì œ ë‚˜ì™€ìš”? ğŸ”¥`
                ],
                long: [
                  `ã…‹ã…‹ã…‹ã…‹ã…‹ "${title}" ì´ê±° ì™„ì „ ë ˆì „ë“œë„¤ìš” ğŸ˜‚ ì²˜ìŒì—” ë­ì§€ í–ˆëŠ”ë° ë³´ë‹¤ë³´ë‹ˆê¹Œ ì™„ì „ ë¹ ì ¸ë“¤ì—ˆì–´ìš”! ì´ëŸ° ì„¼ìŠ¤ ìˆëŠ” ì½˜í…ì¸  ë„ˆë¬´ ì¢‹ìŠµë‹ˆë‹¤ ã…‹ã…‹ êµ¬ë… ì•Œë¦¼ ì„¤ì •ê¹Œì§€ ë‹¤ í–ˆì–´ìš”! ë‹¤ìŒ í¸ë„ ê¸°ëŒ€í• ê²Œìš” ğŸ‰ğŸ”¥`,
                  `ì•„ ã…‹ã…‹ã…‹ ì´ ì˜ìƒ ì§„ì§œ ë¯¸ì³¤ì–´ìš” ğŸ¤£ ${hashtags.length > 0 ? hashtags.map(t => '#' + t).join(' ') + ' ' : ''}ê´€ë ¨ ì˜ìƒ ì¤‘ì— ì œì¼ ì¬ë°Œë„¤ìš”! í¸ì§‘ ì„¼ìŠ¤ ì™„ì „ ì˜¤ì§€ê³ ìš” ã…‹ã…‹ ì•Œê³ ë¦¬ì¦˜ì´ ì´ ì˜ìƒì„ ì™œ ì´ì œì„œì•¼ ì¶”ì²œí•´ì¤€ ê±°ì£ ? ì™„ì „ ì¸ìƒ ì˜ìƒì…ë‹ˆë‹¤ ğŸ‘âœ¨`
                ]
              }
            };
            
            const addEmojis = (text) => {
              if (aiEmojiUsage === 'none') {
                return text.replace(/[ğŸ˜ŠğŸ‘âš½ğŸ‰ğŸ˜‚ğŸ¤£ğŸ”¥âœ¨ğŸ‘]/g, '');
              }
              if (aiEmojiUsage === 'many' && Math.random() < 0.5) {
                const extraEmojis = ['ğŸ’¯', 'ğŸ™Œ', 'â¤ï¸', 'ğŸŠ', 'â­'];
                return text + ' ' + extraEmojis[Math.floor(Math.random() * extraEmojis.length)];
              }
              return text;
            };
            
            const styleTemplates = templates[aiCommentStyle] || templates.friendly;
            const lengthTemplates = styleTemplates[aiCommentLength] || styleTemplates.medium;
            const comment = lengthTemplates[Math.floor(Math.random() * lengthTemplates.length)];
            
            return addEmojis(comment);
          };

          // AI ëŒ“ê¸€ ìƒì„± - ì‹¤ì œ API
          const generateAICommentReal = async (videoData) => {
            if (!anthropicApiKey || anthropicApiKey.length < 10) {
              throw new Error('Anthropic API í‚¤ê°€ í•„ìš”í•©ë‹ˆë‹¤');
            }
            
            try {
              const toneMap = {
                'friendly': 'ì¹œê·¼í•˜ê³  ë”°ëœ»í•œ',
                'formal': 'ì •ì¤‘í•˜ê³  ê²©ì‹ìˆëŠ”',
                'humorous': 'ìœ ë¨¸ëŸ¬ìŠ¤í•˜ê³  ì¬ë¯¸ìˆëŠ”'
              };
              const emojiMap = {
                'none': 'ì´ëª¨ì§€ë¥¼ ì‚¬ìš©í•˜ì§€ ë§ˆì„¸ìš”',
                'moderate': 'ì´ëª¨ì§€ 1-2ê°œë§Œ ìì—°ìŠ¤ëŸ½ê²Œ ì‚¬ìš©',
                'many': 'ì´ëª¨ì§€ 3-4ê°œë¥¼ ì ì ˆíˆ ì‚¬ìš©'
              };
              const lengthMap = {
                'short': '1ë¬¸ì¥ìœ¼ë¡œ ì§§ê²Œ',
                'medium': '2-3ë¬¸ì¥ ì •ë„ë¡œ',
                'long': '3-4ë¬¸ì¥ìœ¼ë¡œ ìì„¸í•˜ê²Œ'
              };
              
              let prompt = `ë‹¤ìŒ YouTube ì˜ìƒì— ë‹¬ ëŒ“ê¸€ì„ ì‘ì„±í•´ì£¼ì„¸ìš”:

ì œëª©: ${videoData.title}
ì±„ë„: ${videoData.channelTitle || 'ì•Œ ìˆ˜ ì—†ìŒ'}
${videoData.description ? `ì„¤ëª…: ${videoData.description.substring(0, 200)}` : ''}
${videoData.hashtags?.length > 0 ? `í•´ì‹œíƒœê·¸: ${videoData.hashtags.map(t => '#' + t).join(' ')}` : ''}

ìš”êµ¬ì‚¬í•­:
- í†¤: ${toneMap[aiCommentStyle]}
- ê¸¸ì´: ${lengthMap[aiCommentLength]}
- ${emojiMap[aiEmojiUsage]}
- ìì—°ìŠ¤ëŸ½ê³  ì§„ì •ì„±ìˆê²Œ
- ìŠ¤íŒ¸ì²˜ëŸ¼ ë³´ì´ì§€ ì•Šê²Œ
- êµ¬ì²´ì ì¸ ë‚´ìš© ì–¸ê¸‰`;

              if (aiAnalyzeImage) {
                prompt += '\n- ì¸ë„¤ì¼ ì´ë¯¸ì§€ì˜ ë¶„ìœ„ê¸°ë¥¼ ê³ ë ¤';
              }
              
              if (aiTrendAware) {
                prompt += '\n- 2025ë…„ ìµœì‹  íŠ¸ë Œë“œì™€ ìœ í–‰ì–´ ë°˜ì˜';
              }
              
              if (aiCustomPrompt) {
                prompt += `\n- ì¶”ê°€ ì§€ì¹¨: ${aiCustomPrompt}`;
              }
              
              prompt += '\n\nëŒ“ê¸€ ë‚´ìš©ë§Œ ì¶œë ¥í•˜ì„¸ìš”:';
              
              const response = await fetch("https://api.anthropic.com/v1/messages", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  "x-api-key": anthropicApiKey,
                  "anthropic-version": "2023-06-01"
                },
                body: JSON.stringify({
                  model: "claude-sonnet-4-20250514",
                  max_tokens: 200,
                  messages: [{ role: "user", content: prompt }]
                })
              });
              
              if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`AI API ì˜¤ë¥˜: ${response.status} - ${errorText}`);
              }
              
              const data = await response.json();
              const aiComment = data.content[0].text.trim();
              
              trackAPIUsage(0, 5);
              return aiComment;
              
            } catch (error) {
              throw error;
            }
          };

          // AI ëŒ“ê¸€ ìƒì„± - í†µí•©
          const generateAIComment = async (videoData) => {
            if (!aiCommentEnabled) return null;
            
            try {
              addLog(`ğŸ¤– AI ëŒ“ê¸€ ìƒì„± ì¤‘... ${aiDemoMode ? '(ë°ëª¨)' : '(ì‹¤ì œ API)'}`, 'info');
              
              let commentText;
              
              if (aiDemoMode) {
                // ë°ëª¨ ëª¨ë“œ: í…œí”Œë¦¿ ê¸°ë°˜
                await new Promise(r => setTimeout(r, 500 + Math.random() * 500));
                commentText = generateAICommentDemo(videoData);
                addLog(`âœ¨ AI ëŒ“ê¸€ (ë°ëª¨): "${commentText.substring(0, 30)}..."`, 'success');
              } else {
                // ì‹¤ì œ ëª¨ë“œ: Anthropic API
                commentText = await generateAICommentReal(videoData);
                addLog(`âœ¨ AI ëŒ“ê¸€ (ì‹¤ì œ): "${commentText.substring(0, 30)}..."`, 'success');
              }
              
              return commentText;
              
            } catch (error) {
              addLog(`âŒ AI ì‹¤íŒ¨: ${error.message}`, 'error');
              return null;
            }
          };

          // ========================================
          // ì±„ë„ ê´€ë¦¬
          // ========================================
          const addChannel = async () => {
            if (!isAuthenticated) {
              alert('ë¨¼ì € ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”!');
              return;
            }
            
            const channelId = prompt('ì±„ë„ IDë¥¼ ì…ë ¥í•˜ì„¸ìš”:\n\n(ì±„ë„ URLì—ì„œ í™•ì¸ ê°€ëŠ¥)\nì˜ˆ: UCxxxxxxxxxxxxxxxxxxxxxx');
            if (!channelId) return;
            
            try {
              // ì±„ë„ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
              const response = await gapi.client.youtube.channels.list({
                part: 'snippet,statistics',
                id: channelId
              });
              
              trackAPIUsage(1);
              
              if (!response.result.items || response.result.items.length === 0) {
                alert('ì±„ë„ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì±„ë„ IDë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.');
                return;
              }
              
              const channelData = response.result.items[0];
              
              // ëŒ“ê¸€ íŒ¨í„´ ì…ë ¥
              const comments = [];
              let addMore = true;
              
              while (addMore && comments.length < 10) {
                const comment = prompt(`"${channelData.snippet.title}" ì±„ë„ìš© ëŒ“ê¸€ íŒ¨í„´ ${comments.length + 1}:\n(ì·¨ì†Œë¥¼ ëˆ„ë¥´ë©´ ì…ë ¥ ì¢…ë£Œ)`);
                if (!comment) {
                  addMore = false;
                } else {
                  comments.push(comment);
                  if (comments.length < 10) {
                    addMore = confirm('ëŒ“ê¸€ íŒ¨í„´ì„ ë” ì¶”ê°€í•˜ì‹œê² ìŠµë‹ˆê¹Œ?');
                  }
                }
              }
              
              if (comments.length === 0) {
                alert('ìµœì†Œ 1ê°œì˜ ëŒ“ê¸€ íŒ¨í„´ì´ í•„ìš”í•©ë‹ˆë‹¤.');
                return;
              }
              
              const ch = {
                id: 'ch_' + Date.now(),
                channelId: channelId,
                title: channelData.snippet.title,
                thumbnail: channelData.snippet.thumbnails.default.url,
                subscriberCount: channelData.statistics.subscriberCount,
                commentPatterns: comments,
                enabled: true,
                addedAt: new Date().toISOString()
              };
              
              setChannels(prev => [...prev, ch]);
              addLog(`ğŸ“º "${ch.title}" ì±„ë„ ì¶”ê°€ (êµ¬ë…ì: ${parseInt(ch.subscriberCount).toLocaleString()}ëª…, ${comments.length}ê°œ íŒ¨í„´)`, 'success');
              
            } catch (error) {
              addLog(`âŒ ì±„ë„ ì¶”ê°€ ì‹¤íŒ¨: ${error.message}`, 'error');
              alert('ì±„ë„ ì¶”ê°€ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.\n' + error.message);
            }
          };

          const removeChannel = (id) => {
            if (confirm('ì´ ì±„ë„ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
              setChannels(prev => prev.filter(c => c.id !== id));
              delete incrementalStateRef.current[id];
              addLog('ì±„ë„ ì‚­ì œë¨', 'info');
            }
          };

          const toggleChannel = (id) => {
            setChannels(prev => prev.map(c => c.id === id ? { ...c, enabled: !c.enabled } : c));
          };

          // ========================================
          // í•´ì‹œíƒœê·¸ & í‚¤ì›Œë“œ
          // ========================================
          const addHashtagRule = () => {
            const hashtag = prompt('í•´ì‹œíƒœê·¸ë¥¼ ì…ë ¥í•˜ì„¸ìš” (# ì œì™¸):');
            if (!hashtag) return;
            
            const comments = [];
            let addMore = true;
            
            while (addMore && comments.length < 10) {
              const comment = prompt(`"#${hashtag}" íƒœê·¸ìš© ëŒ“ê¸€ ${comments.length + 1}:`);
              if (!comment) {
                addMore = false;
              } else {
                comments.push(comment);
                if (comments.length < 10) {
                  addMore = confirm('ëŒ“ê¸€ì„ ë” ì¶”ê°€í•˜ì‹œê² ìŠµë‹ˆê¹Œ?');
                }
              }
            }
            
            if (comments.length === 0) return;
            
            setHashtagRules(prev => [...prev, {
              id: 'tag_' + Date.now(),
              hashtag: hashtag.replace('#', ''),
              commentPatterns: comments,
              enabled: true
            }]);
            addLog(`ğŸ·ï¸ "#${hashtag}" ê·œì¹™ ì¶”ê°€`, 'success');
          };

          const removeHashtagRule = (id) => {
            if (confirm('ì´ í•´ì‹œíƒœê·¸ ê·œì¹™ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
              setHashtagRules(prev => prev.filter(r => r.id !== id));
              addLog('í•´ì‹œíƒœê·¸ ê·œì¹™ ì‚­ì œë¨', 'info');
            }
          };

          const toggleHashtagRule = (id) => {
            setHashtagRules(prev => prev.map(r => r.id === id ? { ...r, enabled: !r.enabled } : r));
          };

          const addKeywordRule = () => {
            const keyword = prompt('í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”:');
            if (!keyword) return;
            
            const comments = [];
            let addMore = true;
            
            while (addMore && comments.length < 10) {
              const comment = prompt(`"${keyword}" í‚¤ì›Œë“œìš© ëŒ“ê¸€ ${comments.length + 1}:`);
              if (!comment) {
                addMore = false;
              } else {
                comments.push(comment);
                if (comments.length < 10) {
                  addMore = confirm('ëŒ“ê¸€ì„ ë” ì¶”ê°€í•˜ì‹œê² ìŠµë‹ˆê¹Œ?');
                }
              }
            }
            
            if (comments.length === 0) return;
            
            setKeywordRules(prev => [...prev, {
              id: 'kw_' + Date.now(),
              keyword: keyword,
              commentPatterns: comments,
              enabled: true
            }]);
            addLog(`ğŸ” "${keyword}" í‚¤ì›Œë“œ ì¶”ê°€`, 'success');
          };

          const removeKeywordRule = (id) => {
            if (confirm('ì´ í‚¤ì›Œë“œ ê·œì¹™ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
              setKeywordRules(prev => prev.filter(r => r.id !== id));
              addLog('í‚¤ì›Œë“œ ê·œì¹™ ì‚­ì œë¨', 'info');
            }
          };

          const toggleKeywordRule = (id) => {
            setKeywordRules(prev => prev.map(r => r.id === id ? { ...r, enabled: !r.enabled } : r));
          };

          const getRandomComment = (patterns) => {
            return patterns[Math.floor(Math.random() * patterns.length)];
          };

          // ========================================
          // ì‹¤ì œ ëŒ“ê¸€ ì‘ì„±
          // ========================================
          const postCommentToYouTube = async (videoId, commentText) => {
            try {
              const response = await gapi.client.youtube.commentThreads.insert({
                part: 'snippet',
                resource: {
                  snippet: {
                    videoId: videoId,
                    topLevelComment: {
                      snippet: {
                        textOriginal: commentText
                      }
                    }
                  }
                }
              });
              
              trackAPIUsage(50);
              return response.result;
              
            } catch (error) {
              throw new Error(`ëŒ“ê¸€ ì‘ì„± ì‹¤íŒ¨: ${error.message}`);
            }
          };

          // ========================================
          // ëª¨ë‹ˆí„°ë§ - ì±„ë„
          // ========================================
          const checkNewVideos = async () => {
            if (channels.length === 0 && hashtagRules.length === 0 && keywordRules.length === 0) {
              addLog('ì±„ë„, í•´ì‹œíƒœê·¸, ë˜ëŠ” í‚¤ì›Œë“œë¥¼ ë¨¼ì € ì¶”ê°€í•˜ì„¸ìš”', 'warning');
              return;
            }
            
            const optimizationStatus = [];
            if (cacheEnabled) optimizationStatus.push('ğŸ’¾ ìºì‹±');
            if (incrementalEnabled) optimizationStatus.push('âš¡ ì¦ë¶„');
            if (headCheckEnabled) optimizationStatus.push('ğŸ¯ HEAD');
            if (aiCommentEnabled) optimizationStatus.push(`ğŸ¤– AI${aiDemoMode ? '(ë°ëª¨)' : ''}`);
            
            addLog(`ğŸ” ëª¨ë‹ˆí„°ë§ ì‹œì‘ [${optimizationStatus.join(' | ')}]`, 'info');
            
            let totalSaved = 0;
            let totalCost = 0;
            
            // ì±„ë„ ëª¨ë‹ˆí„°ë§
            for (const ch of channels.filter(c => c.enabled)) {
              try {
                // 1ë‹¨ê³„: HEAD ì²´í¬
                const headResult = await headCheck(ch);
                totalCost += headResult.apiCost;
                
                if (!headResult.hasNew) {
                  const saved = 98;
                  totalSaved += saved;
                  trackAPIUsage(0, 0, saved);
                  addLog(`âœ“ "${ch.title}" ë³€ê²½ ì—†ìŒ [${headResult.method}] (-${saved} units)`, 'info');
                  continue;
                }
                
                // 2ë‹¨ê³„: ì¦ë¶„ ì²´í¬
                const incrementalResult = await performIncrementalCheck(ch);
                totalCost += incrementalResult.apiCost;
                
                if (!incrementalResult.hasNew && incrementalResult.method === '304_NOT_MODIFIED') {
                  const saved = 99;
                  totalSaved += saved;
                  trackAPIUsage(0, 0, saved);
                  addLog(`âœ“ "${ch.title}" 304 Not Modified (-${saved} units)`, 'info');
                  continue;
                }
                
                // 3ë‹¨ê³„: ì‹¤ì œ ì˜ìƒ ê²€ìƒ‰
                const response = await gapi.client.youtube.search.list({
                  part: 'snippet',
                  channelId: ch.channelId,
                  order: 'date',
                  maxResults: 5,
                  type: 'video'
                });
                
                trackAPIUsage(100);
                totalCost += 100;
                
                if (response.result.items && response.result.items.length > 0) {
                  for (const item of response.result.items) {
                    const videoData = {
                      id: item.id.videoId,
                      title: item.snippet.title,
                      channelTitle: item.snippet.channelTitle,
                      description: item.snippet.description,
                      thumbnail: item.snippet.thumbnails.default.url,
                      publishedAt: item.snippet.publishedAt,
                      link: `https://www.youtube.com/watch?v=${item.id.videoId}`
                    };
                    
                    setNewVideos(prev => [videoData, ...prev].slice(0, 50));
                    addLog(`ğŸ¬ ìƒˆ ì˜ìƒ: "${videoData.title.substring(0, 30)}..."`, 'success');
                    
                    // ìë™ ëŒ“ê¸€
                    if (autoCommentEnabled && ch.commentPatterns.length > 0) {
                      await new Promise(r => setTimeout(r, 1000));
                      
                      let commentText;
                      
                      if (aiCommentEnabled) {
                        commentText = await generateAIComment(videoData);
                        if (!commentText) {
                          commentText = getRandomComment(ch.commentPatterns);
                          addLog(`âš ï¸ AI ì‹¤íŒ¨, íŒ¨í„´ ì‚¬ìš©`, 'warning');
                        }
                      } else {
                        commentText = getRandomComment(ch.commentPatterns);
                      }
                      
                      try {
                        // ì‹¤ì œ ëŒ“ê¸€ ì‘ì„±
                        const commentResult = await postCommentToYouTube(videoData.id, commentText);
                        
                        setComments(prev => [{
                          id: commentResult.id,
                          text: commentText,
                          video: videoData.title,
                          videoLink: videoData.link,
                          commentLink: `${videoData.link}&lc=${commentResult.id}`,
                          time: new Date().toLocaleTimeString(),
                          source: `ì±„ë„: ${ch.title}`,
                          auto: true,
                          isAI: aiCommentEnabled,
                          posted: true
                        }, ...prev].slice(0, 100));
                        
                        const badge = aiCommentEnabled ? 'ğŸ¤– AI' : 'ğŸ“';
                        addLog(`âœ… ${badge} ëŒ“ê¸€ ì‘ì„± ì™„ë£Œ: "${commentText.substring(0, 25)}..." [50 units]`, 'success');
                        
                      } catch (error) {
                        addLog(`âŒ ëŒ“ê¸€ ì‘ì„± ì‹¤íŒ¨: ${error.message}`, 'error');
                      }
                    }
                  }
                }
                
              } catch (error) {
                addLog(`âŒ "${ch.title}" ì²˜ë¦¬ ì‹¤íŒ¨: ${error.message}`, 'error');
              }
            }
            
            // í•´ì‹œíƒœê·¸ ê²€ìƒ‰
            if (hashtagEnabled) {
              for (const rule of hashtagRules.filter(r => r.enabled)) {
                try {
                  const response = await gapi.client.youtube.search.list({
                    part: 'snippet',
                    q: `#${rule.hashtag}`,
                    order: 'date',
                    maxResults: 3,
                    type: 'video'
                  });
                  
                  trackAPIUsage(100);
                  totalCost += 100;
                  
                  if (response.result.items && response.result.items.length > 0) {
                    addLog(`ğŸ·ï¸ #${rule.hashtag} ì˜ìƒ ${response.result.items.length}ê°œ ë°œê²¬`, 'success');
                    
                    for (const item of response.result.items) {
                      const videoData = {
                        id: item.id.videoId,
                        title: item.snippet.title,
                        channelTitle: item.snippet.channelTitle,
                        description: item.snippet.description,
                        hashtags: [rule.hashtag],
                        link: `https://www.youtube.com/watch?v=${item.id.videoId}`
                      };
                      
                      setNewVideos(prev => [videoData, ...prev].slice(0, 50));
                      
                      if (autoCommentEnabled && rule.commentPatterns.length > 0) {
                        let commentText;
                        if (aiCommentEnabled) {
                          commentText = await generateAIComment(videoData);
                          if (!commentText) commentText = getRandomComment(rule.commentPatterns);
                        } else {
                          commentText = getRandomComment(rule.commentPatterns);
                        }
                        
                        try {
                          const commentResult = await postCommentToYouTube(videoData.id, commentText);
                          setComments(prev => [{
                            id: commentResult.id,
                            text: commentText,
                            video: videoData.title,
                            videoLink: videoData.link,
                            commentLink: `${videoData.link}&lc=${commentResult.id}`,
                            time: new Date().toLocaleTimeString(),
                            source: `í•´ì‹œíƒœê·¸: #${rule.hashtag}`,
                            auto: true,
                            isAI: aiCommentEnabled,
                            posted: true
                          }, ...prev].slice(0, 100));
                          
                          addLog(`âœ… #${rule.hashtag} ëŒ“ê¸€ ì‘ì„± ì™„ë£Œ`, 'success');
                        } catch (error) {
                          addLog(`âŒ ëŒ“ê¸€ ì‘ì„± ì‹¤íŒ¨: ${error.message}`, 'error');
                        }
                        
                        await new Promise(r => setTimeout(r, 2000));
                      }
                    }
                  }
                } catch (error) {
                  addLog(`âŒ #${rule.hashtag} ê²€ìƒ‰ ì‹¤íŒ¨: ${error.message}`, 'error');
                }
              }
            }
            
            // í‚¤ì›Œë“œ ê²€ìƒ‰
            if (keywordEnabled) {
              for (const rule of keywordRules.filter(r => r.enabled)) {
                try {
                  const response = await gapi.client.youtube.search.list({
                    part: 'snippet',
                    q: rule.keyword,
                    order: 'date',
                    maxResults: keywordMaxResults,
                    type: 'video'
                  });
                  
                  trackAPIUsage(100);
                  totalCost += 100;
                  
                  if (response.result.items && response.result.items.length > 0) {
                    addLog(`ğŸ” "${rule.keyword}" ì˜ìƒ ${response.result.items.length}ê°œ ë°œê²¬`, 'success');
                    
                    for (const item of response.result.items) {
                      const videoData = {
                        id: item.id.videoId,
                        title: item.snippet.title,
                        channelTitle: item.snippet.channelTitle,
                        link: `https://www.youtube.com/watch?v=${item.id.videoId}`
                      };
                      
                      setNewVideos(prev => [videoData, ...prev].slice(0, 50));
                      
                      if (autoCommentEnabled && rule.commentPatterns.length > 0) {
                        let commentText;
                        if (aiCommentEnabled) {
                          commentText = await generateAIComment(videoData);
                          if (!commentText) commentText = getRandomComment(rule.commentPatterns);
                        } else {
                          commentText = getRandomComment(rule.commentPatterns);
                        }
                        
                        try {
                          const commentResult = await postCommentToYouTube(videoData.id, commentText);
                          setComments(prev => [{
                            id: commentResult.id,
                            text: commentText,
                            video: videoData.title,
                            videoLink: videoData.link,
                            commentLink: `${videoData.link}&lc=${commentResult.id}`,
                            time: new Date().toLocaleTimeString(),
                            source: `í‚¤ì›Œë“œ: "${rule.keyword}"`,
                            auto: true,
                            isAI: aiCommentEnabled,
                            posted: true
                          }, ...prev].slice(0, 100));
                          
                          addLog(`âœ… "${rule.keyword}" ëŒ“ê¸€ ì‘ì„± ì™„ë£Œ`, 'success');
                        } catch (error) {
                          addLog(`âŒ ëŒ“ê¸€ ì‘ì„± ì‹¤íŒ¨: ${error.message}`, 'error');
                        }
                        
                        await new Promise(r => setTimeout(r, 2000));
                      }
                    }
                  }
                } catch (error) {
                  addLog(`âŒ "${rule.keyword}" ê²€ìƒ‰ ì‹¤íŒ¨: ${error.message}`, 'error');
                }
              }
            }
            
            if (totalSaved > 0) {
              const efficiency = ((totalSaved / (totalCost + totalSaved)) * 100).toFixed(1);
              addLog(`ğŸ’° ì´ ${totalSaved} units ì ˆì•½! (íš¨ìœ¨: ${efficiency}%)`, 'success');
            }
            
            addLog(`âœ… í™•ì¸ ì™„ë£Œ (YouTube API: ${totalCost} units / ì ˆì•½: ${totalSaved} units)`, 'info');
          };

          const startMonitoring = () => {
            if (channels.length === 0 && hashtagRules.length === 0 && keywordRules.length === 0) {
              alert('ì±„ë„, í•´ì‹œíƒœê·¸, ë˜ëŠ” í‚¤ì›Œë“œë¥¼ ë¨¼ì € ì¶”ê°€í•˜ì„¸ìš”!');
              return;
            }
            
            setIsMonitoring(true);
            addLog(`ğŸš€ ëª¨ë‹ˆí„°ë§ ì‹œì‘ (${checkInterval}ë¶„ ê°„ê²©)`, 'success');
            const status = [];
            if (cacheEnabled) status.push('ìºì‹±');
            if (incrementalEnabled) status.push('ì¦ë¶„');
            if (headCheckEnabled) status.push('HEAD');
            if (aiCommentEnabled) status.push(`AI${aiDemoMode ? '(ë°ëª¨)' : ''}`);
            addLog(`âš™ï¸ ìµœì í™”: ${status.join(' + ')}`, 'info');
            
            checkNewVideos();
            monitoringRef.current = setInterval(checkNewVideos, checkInterval * 60 * 1000);
          };

          const stopMonitoring = () => {
            if (monitoringRef.current) clearInterval(monitoringRef.current);
            monitoringRef.current = null;
            setIsMonitoring(false);
            addLog('â¸ï¸ ëª¨ë‹ˆí„°ë§ ì¤‘ì§€', 'warning');
          };

          // ========================================
          // ë¡œê·¸ì¸ í™”ë©´
          // ========================================
          if (!isAuthenticated) {
            return (
              <div className="min-h-screen bg-gradient-to-br from-red-500 via-purple-600 to-pink-600 flex items-center justify-center p-4">
                <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full text-center">
                  <div className="bg-gradient-to-r from-purple-100 to-pink-100 rounded-full w-20 h-20 flex items-center justify-center mx-auto mb-6">
                    <span className="text-4xl">ğŸ¤–</span>
                  </div>
                  <h1 className="text-2xl font-bold text-gray-800 mb-2 flex items-center justify-center gap-2">
                    YouTube Auto Manager
                    <span className="pro-badge">PRO</span>
                  </h1>
                  <p className="text-gray-600 mb-2">ì •ì‹ ë²„ì „</p>
                  <p className="text-sm text-gray-500 mb-6">âœ¨ ì‹¤ì œ YouTube API + AI ëŒ“ê¸€</p>
                  
                  <button onClick={handleLogin}
                    className="w-full bg-gradient-to-r from-red-600 to-purple-600 text-white py-4 rounded-xl font-semibold hover:from-red-700 hover:to-purple-700 transition shadow-lg">
                    ğŸ”‘ Google ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸
                  </button>
                  
                  <div className="mt-6 p-4 bg-gradient-to-r from-purple-50 to-pink-50 rounded-lg text-xs text-left border-2 border-purple-200">
                    <p className="font-bold text-purple-800 mb-2">ğŸ‰ ì •ì‹ ë²„ì „ ê¸°ëŠ¥</p>
                    <ul className="text-purple-700 space-y-1">
                      <li>â€¢ âœ… ì‹¤ì œ YouTube ì±„ë„ & ì˜ìƒ ê²€ìƒ‰</li>
                      <li>â€¢ âœ… ì‹¤ì œ ëŒ“ê¸€ ì‘ì„± (YouTubeì— ì˜¬ë¼ê°!)</li>
                      <li>â€¢ ğŸ¤– ì‹¤ì œ AI ëŒ“ê¸€ (Anthropic API)</li>
                      <li>â€¢ ğŸ’¾ ìŠ¤ë§ˆíŠ¸ ìºì‹± (70-80% ì ˆì•½)</li>
                      <li>â€¢ âš¡ ì¦ë¶„ ì²´í¬ (85-90% ì ˆì•½)</li>
                      <li>â€¢ ğŸ¯ HEAD ìš”ì²­ (95-98% ì ˆì•½)</li>
                    </ul>
                  </div>
                  
                  {YOUTUBE_CLIENT_ID === 'YOUR_YOUTUBE_CLIENT_ID_HERE' && (
                    <div className="mt-4 p-3 bg-red-50 border-2 border-red-200 rounded-lg text-xs text-left">
                      <p className="font-bold text-red-800 mb-1">âš ï¸ API ì„¤ì • í•„ìš”</p>
                      <p className="text-red-700">ì½”ë“œ ìƒë‹¨ì˜ YOUTUBE_CLIENT_IDì™€ YOUTUBE_API_KEYë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.</p>
                    </div>
                  )}
                </div>
              </div>
            );
          }

          const cacheStats = getCacheStats();
          const youtubeSaved = apiUsage.saved;
          const savedPercentage = (apiUsage.youtube + apiUsage.saved) > 0 
            ? ((apiUsage.saved / (apiUsage.youtube + apiUsage.saved)) * 100).toFixed(1) 
            : 0;

          // ========================================
          // ë©”ì¸ UI (ë‚˜ë¨¸ì§€ëŠ” ë°ëª¨ ë²„ì „ê³¼ ìœ ì‚¬í•˜ë‚˜ API ì„¤ì • íƒ­ ì¶”ê°€)
          // ========================================
          return (
            <div className="min-h-screen bg-gray-100">
              <header className="bg-white shadow-sm sticky top-0 z-50">
                <div className="max-w-6xl mx-auto px-4 py-3 flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <span className="text-2xl">ğŸ¤–</span>
                    <div>
                      <h1 className="font-bold text-gray-800 flex items-center gap-2">
                        YouTube Manager 
                        <span className="pro-badge">PRO</span>
                      </h1>
                      {isMonitoring && (
                        <p className="text-xs text-green-600 flex items-center gap-1">
                          <span className="animate-pulse">â—</span> ëª¨ë‹ˆí„°ë§ ì¤‘
                          {cacheEnabled && <span>| ğŸ’¾</span>}
                          {incrementalEnabled && <span>| âš¡</span>}
                          {headCheckEnabled && <span>| ğŸ¯</span>}
                          {aiCommentEnabled && <span className="ai-badge text-white px-2 py-0.5 rounded text-xs">
                            AI{aiDemoMode ? '(ë°ëª¨)' : ''}
                          </span>}
                        </p>
                      )}
                    </div>
                  </div>
                  <div className="flex items-center gap-3">
                    <div className="text-right text-xs">
                      <p className="font-bold text-gray-800">YouTube: {apiUsage.youtube.toLocaleString()}/10K</p>
                      {apiUsage.ai > 0 && <p className="text-purple-600 font-bold">AI: ${(apiUsage.ai * 0.0011).toFixed(2)}</p>}
                      {apiUsage.saved > 0 && (
                        <p className="text-green-600 font-bold">ì ˆì•½: {apiUsage.saved.toLocaleString()} ({savedPercentage}%)</p>
                      )}
                    </div>
                    {user && (
                      <img src={user.image} alt={user.name} className="w-8 h-8 rounded-full" />
                    )}
                    <button onClick={handleLogout} className="text-gray-500 hover:text-red-600 text-sm font-medium">ë¡œê·¸ì•„ì›ƒ</button>
                  </div>
                </div>
                
                <div className="max-w-6xl mx-auto px-4 flex gap-1 border-t overflow-x-auto">
                  <div className={`tab ${currentTab === 'home' ? 'active' : ''}`} onClick={() => setCurrentTab('home')}>ğŸ  í™ˆ</div>
                  <div className={`tab ${currentTab === 'channels' ? 'active' : ''}`} onClick={() => setCurrentTab('channels')}>ğŸ“º ì±„ë„</div>
                  <div className={`tab ${currentTab === 'hashtags' ? 'active' : ''}`} onClick={() => setCurrentTab('hashtags')}>ğŸ·ï¸ í•´ì‹œíƒœê·¸</div>
                  <div className={`tab ${currentTab === 'keywords' ? 'active' : ''}`} onClick={() => setCurrentTab('keywords')}>ğŸ” í‚¤ì›Œë“œ</div>
                  <div className={`tab ${currentTab === 'ai' ? 'active' : ''}`} onClick={() => setCurrentTab('ai')}>
                    ğŸ¤– AI {aiCommentEnabled && <span className="text-xs bg-purple-600 text-white px-1 rounded">ON</span>}
                  </div>
                  <div className={`tab ${currentTab === 'api' ? 'active' : ''}`} onClick={() => setCurrentTab('api')}>ğŸ”‘ API ì„¤ì •</div>
                  <div className={`tab ${currentTab === 'optimization' ? 'active' : ''}`} onClick={() => setCurrentTab('optimization')}>âš™ï¸ ìµœì í™”</div>
                  <div className={`tab ${currentTab === 'comments' ? 'active' : ''}`} onClick={() => setCurrentTab('comments')}>ğŸ’¬ ëŒ“ê¸€</div>
                  <div className={`tab ${currentTab === 'logs' ? 'active' : ''}`} onClick={() => setCurrentTab('logs')}>ğŸ“‹ ë¡œê·¸</div>
                </div>
              </header>
              
              <main className="max-w-6xl mx-auto px-4 py-6">
                {/* í™ˆ íƒ­ - ë°ëª¨ì™€ ìœ ì‚¬í•˜ì§€ë§Œ ì‹¤ì œ í†µê³„ */}
                {currentTab === 'home' && (
                  <div className="space-y-6">
                    {/* í†µê³„ ì¹´ë“œ */}
                    <div className="grid grid-cols-2 md:grid-cols-5 gap-4">
                      <div className="bg-white rounded-xl p-4 text-center shadow-sm">
                        <p className="text-3xl font-bold text-red-600">{channels.length}</p>
                        <p className="text-sm text-gray-600">ì±„ë„</p>
                      </div>
                      <div className="bg-white rounded-xl p-4 text-center shadow-sm">
                        <p className="text-3xl font-bold text-purple-600">{hashtagRules.length}</p>
                        <p className="text-sm text-gray-600">í•´ì‹œíƒœê·¸</p>
                      </div>
                      <div className="bg-white rounded-xl p-4 text-center shadow-sm">
                        <p className="text-3xl font-bold text-orange-600">{keywordRules.length}</p>
                        <p className="text-sm text-gray-600">í‚¤ì›Œë“œ</p>
                      </div>
                      <div className="bg-white rounded-xl p-4 text-center shadow-sm">
                        <p className="text-3xl font-bold text-blue-600">{newVideos.length}</p>
                        <p className="text-sm text-gray-600">ë°œê²¬</p>
                      </div>
                      <div className="bg-white rounded-xl p-4 text-center shadow-sm relative">
                        <p className="text-3xl font-bold text-green-600">{comments.length}</p>
                        <p className="text-sm text-gray-600">ëŒ“ê¸€ ì‘ì„±</p>
                        {aiCommentEnabled && <span className="absolute top-2 right-2 text-xs bg-purple-600 text-white px-2 py-1 rounded-full">AI</span>}
                      </div>
                    </div>

                    {/* ëª¨ë‹ˆí„°ë§ ì œì–´ - ë°ëª¨ì™€ ë™ì¼ */}
                    <div className="bg-white rounded-xl p-6 shadow-sm">
                      <h2 className="font-bold mb-4">âš™ï¸ ëª¨ë‹ˆí„°ë§ ì œì–´</h2>
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div className="space-y-3">
                          <label className="flex items-center gap-2">
                            <input type="checkbox" checked={autoCommentEnabled} 
                              onChange={e => setAutoCommentEnabled(e.target.checked)} className="w-4 h-4" />
                            <span className="text-sm">ìë™ ëŒ“ê¸€</span>
                          </label>
                          <label className="flex items-center gap-2">
                            <input type="checkbox" checked={hashtagEnabled} 
                              onChange={e => setHashtagEnabled(e.target.checked)} className="w-4 h-4" />
                            <span className="text-sm">í•´ì‹œíƒœê·¸ ëª¨ë‹ˆí„°ë§</span>
                          </label>
                          <label className="flex items-center gap-2">
                            <input type="checkbox" checked={keywordEnabled} 
                              onChange={e => setKeywordEnabled(e.target.checked)} className="w-4 h-4" />
                            <span className="text-sm">í‚¤ì›Œë“œ ê²€ìƒ‰</span>
                          </label>
                          <label className="flex items-center gap-2">
                            <input type="checkbox" checked={aiCommentEnabled} 
                              onChange={e => setAiCommentEnabled(e.target.checked)} className="w-4 h-4" />
                            <span className="text-sm font-bold text-purple-600">ğŸ¤– AI ëŒ“ê¸€</span>
                          </label>
                        </div>
                        <div className="space-y-3">
                          <div>
                            <label className="text-sm text-gray-600 block mb-1">í™•ì¸ ê°„ê²© (ë¶„)</label>
                            <input type="number" value={checkInterval} 
                              onChange={e => setCheckInterval(Math.max(1, parseInt(e.target.value) || 1))}
                              className="w-full border rounded-lg px-3 py-2 text-sm" min="1" />
                          </div>
                        </div>
                      </div>
                      
                      <div className="mt-6 flex gap-3">
                        {!isMonitoring ? (
                          <button onClick={startMonitoring}
                            className="flex-1 bg-green-600 text-white py-3 rounded-lg font-bold hover:bg-green-700">
                            ğŸš€ ëª¨ë‹ˆí„°ë§ ì‹œì‘
                          </button>
                        ) : (
                          <button onClick={stopMonitoring}
                            className="flex-1 bg-red-600 text-white py-3 rounded-lg font-bold hover:bg-red-700">
                            â¸ï¸ ì¤‘ì§€
                          </button>
                        )}
                        <button onClick={checkNewVideos}
                          className="px-6 bg-blue-600 text-white py-3 rounded-lg font-bold hover:bg-blue-700">
                          ğŸ” ìˆ˜ë™ í™•ì¸
                        </button>
                      </div>
                    </div>
                  </div>
                )}

                {/* API ì„¤ì • íƒ­ (NEW!) */}
                {currentTab === 'api' && (
                  <div className="space-y-6">
                    <div className="bg-white rounded-xl p-6 shadow-sm">
                      <h2 className="font-bold mb-4 text-lg">ğŸ”‘ Anthropic API ì„¤ì •</h2>
                      
                      <div className="space-y-4">
                        <div className="p-4 bg-yellow-50 border-2 border-yellow-200 rounded-lg">
                          <p className="text-sm text-yellow-800 mb-2">
                            ğŸ’¡ <strong>AI ë°ëª¨ ëª¨ë“œ</strong>ì™€ <strong>ì‹¤ì œ API ëª¨ë“œ</strong> ì¤‘ ì„ íƒí•˜ì„¸ìš”.
                          </p>
                          <p className="text-xs text-yellow-700">
                            â€¢ ë°ëª¨ ëª¨ë“œ: í…œí”Œë¦¿ ê¸°ë°˜ ëŒ“ê¸€ ìƒì„± (ë¬´ë£Œ, API í‚¤ ë¶ˆí•„ìš”)<br/>
                            â€¢ ì‹¤ì œ ëª¨ë“œ: Claude AIë¡œ ê³ í’ˆì§ˆ ëŒ“ê¸€ ìƒì„± (API í‚¤ í•„ìš”, ìœ ë£Œ)
                          </p>
                        </div>

                        <label className="flex items-center gap-3 p-4 bg-gray-50 rounded-lg cursor-pointer">
                          <input type="checkbox" checked={aiDemoMode} 
                            onChange={e => setAiDemoMode(e.target.checked)} className="w-5 h-5" />
                          <div>
                            <p className="font-medium">AI ë°ëª¨ ëª¨ë“œ ì‚¬ìš©</p>
                            <p className="text-xs text-gray-600">ì²´í¬ í•´ì œ ì‹œ ì‹¤ì œ Anthropic API ì‚¬ìš©</p>
                          </div>
                        </label>

                        {!aiDemoMode && (
                          <div>
                            <label className="text-sm font-medium block mb-2">Anthropic API í‚¤</label>
                            <input 
                              type="password"
                              value={anthropicApiKey}
                              onChange={e => setAnthropicApiKey(e.target.value)}
                              placeholder="sk-ant-api03-..."
                              className="w-full border rounded-lg px-3 py-2 text-sm"
                            />
                            <p className="text-xs text-gray-500 mt-1">
                              API í‚¤ëŠ” ë¸Œë¼ìš°ì €ì—ë§Œ ì €ì¥ë©ë‹ˆë‹¤ (ì„œë²„ ì „ì†¡ ì•ˆ ë¨)
                            </p>
                            
                            {anthropicApiKey.length > 0 && anthropicApiKey.length < 10 && (
                              <p className="text-xs text-red-600 mt-1">âš ï¸ API í‚¤ê°€ ë„ˆë¬´ ì§§ìŠµë‹ˆë‹¤</p>
                            )}
                            
                            {anthropicApiKey.length >= 10 && (
                              <p className="text-xs text-green-600 mt-1">âœ… API í‚¤ ì €ì¥ë¨</p>
                            )}
                          </div>
                        )}

                        <div className="p-4 bg-blue-50 border-2 border-blue-200 rounded-lg">
                          <p className="text-sm font-bold text-blue-800 mb-2">ğŸ“š API í‚¤ ë°œê¸‰ ë°©ë²•</p>
                          <ol className="text-xs text-blue-700 space-y-1 list-decimal list-inside">
                            <li>https://console.anthropic.com ì ‘ì†</li>
                            <li>ê³„ì • ìƒì„± ($5 ë¬´ë£Œ í¬ë ˆë”§ ì œê³µ)</li>
                            <li>"API Keys" ë©”ë‰´ì—ì„œ "Create Key" í´ë¦­</li>
                            <li>ìƒì„±ëœ í‚¤ë¥¼ ìœ„ì— ì…ë ¥</li>
                          </ol>
                        </div>

                        <div className="grid grid-cols-2 gap-3">
                          <div className="p-3 bg-white border rounded-lg">
                            <p className="text-xs text-gray-600">í˜„ì¬ ëª¨ë“œ</p>
                            <p className="font-bold">{aiDemoMode ? 'ğŸ­ ë°ëª¨' : 'ğŸ¤– ì‹¤ì œ API'}</p>
                          </div>
                          <div className="p-3 bg-white border rounded-lg">
                            <p className="text-xs text-gray-600">AI ì‚¬ìš©ëŸ‰</p>
                            <p className="font-bold">${(apiUsage.ai * 0.0011).toFixed(3)}</p>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                )}

                {/* ë‚˜ë¨¸ì§€ íƒ­ë“¤ - ë°ëª¨ ë²„ì „ê³¼ ë™ì¼ êµ¬ì¡° */}
                {/* ì±„ë„, í•´ì‹œíƒœê·¸, í‚¤ì›Œë“œ, AI ì„¤ì •, ìµœì í™”, ëŒ“ê¸€, ë¡œê·¸ íƒ­ */}
                {/* (Part 4ì—ì„œ ê³„ì†...) */}
              </main>
            </div>
          );
        }

        ReactDOM.render(<YouTubeAutoManager />, document.getElementById('root'));
    </script>
</body>
</html>
                {/* ì±„ë„ íƒ­ */}
                {currentTab === 'channels' && (
                  <div className="bg-white rounded-xl p-6 shadow-sm">
                    <div className="flex justify-between items-center mb-4">
                      <h2 className="font-bold">ğŸ“º ì±„ë„ ê´€ë¦¬</h2>
                      <button onClick={addChannel}
                        className="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 font-medium">
                        + ì±„ë„ ì¶”ê°€
                      </button>
                    </div>
                    {channels.length === 0 ? (
                      <div className="text-center py-12 text-gray-400">
                        <p className="text-5xl mb-4">ğŸ“º</p>
                        <p>ë“±ë¡ëœ ì±„ë„ì´ ì—†ìŠµë‹ˆë‹¤</p>
                      </div>
                    ) : (
                      <div className="space-y-3">
                        {channels.map(ch => (
                          <div key={ch.id} className={`p-4 rounded-lg border-2 ${ch.enabled ? 'bg-green-50 border-green-200' : 'bg-gray-50 border-gray-200'}`}>
                            <div className="flex items-start gap-3">
                              {ch.thumbnail && <img src={ch.thumbnail} className="w-12 h-12 rounded-full" alt={ch.title} />}
                              <div className="flex-1">
                                <p className="font-bold">{ch.title}</p>
                                <p className="text-sm text-gray-600 mt-1">
                                  êµ¬ë…ì: {parseInt(ch.subscriberCount || 0).toLocaleString()}ëª… | íŒ¨í„´: {ch.commentPatterns.length}ê°œ
                                  {aiCommentEnabled && <span className="ml-2 text-purple-600 font-bold">+ ğŸ¤– AI</span>}
                                </p>
                              </div>
                              <div className="flex gap-2">
                                <button onClick={() => toggleChannel(ch.id)}
                                  className={`px-3 py-1 rounded-lg text-sm ${ch.enabled ? 'bg-gray-200' : 'bg-green-600 text-white'}`}>
                                  {ch.enabled ? 'ë¹„í™œì„±í™”' : 'í™œì„±í™”'}
                                </button>
                                <button onClick={() => removeChannel(ch.id)}
                                  className="px-3 py-1 bg-red-600 text-white rounded-lg text-sm">
                                  ì‚­ì œ
                                </button>
                              </div>
                            </div>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                )}

                {/* í•´ì‹œíƒœê·¸ íƒ­ */}
                {currentTab === 'hashtags' && (
                  <div className="bg-white rounded-xl p-6 shadow-sm">
                    <div className="flex justify-between items-center mb-4">
                      <h2 className="font-bold">ğŸ·ï¸ í•´ì‹œíƒœê·¸ ê·œì¹™</h2>
                      <button onClick={addHashtagRule}
                        className="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 font-medium">
                        + í•´ì‹œíƒœê·¸ ì¶”ê°€
                      </button>
                    </div>
                    {hashtagRules.length === 0 ? (
                      <div className="text-center py-12 text-gray-400">
                        <p className="text-5xl mb-4">ğŸ·ï¸</p>
                        <p>ë“±ë¡ëœ í•´ì‹œíƒœê·¸ê°€ ì—†ìŠµë‹ˆë‹¤</p>
                      </div>
                    ) : (
                      <div className="space-y-3">
                        {hashtagRules.map(rule => (
                          <div key={rule.id} className={`p-4 rounded-lg border-2 ${rule.enabled ? 'bg-purple-50 border-purple-200' : 'bg-gray-50 border-gray-200'}`}>
                            <div className="flex justify-between items-start">
                              <div>
                                <p className="font-bold">#{rule.hashtag}</p>
                                <p className="text-sm text-gray-600 mt-1">
                                  íŒ¨í„´: {rule.commentPatterns.length}ê°œ
                                  {aiCommentEnabled && <span className="ml-2 text-purple-600 font-bold">+ ğŸ¤– AI</span>}
                                </p>
                              </div>
                              <div className="flex gap-2">
                                <button onClick={() => toggleHashtagRule(rule.id)}
                                  className={`px-3 py-1 rounded-lg text-sm ${rule.enabled ? 'bg-gray-200' : 'bg-purple-600 text-white'}`}>
                                  {rule.enabled ? 'ë¹„í™œì„±í™”' : 'í™œì„±í™”'}
                                </button>
                                <button onClick={() => removeHashtagRule(rule.id)}
                                  className="px-3 py-1 bg-red-600 text-white rounded-lg text-sm">
                                  ì‚­ì œ
                                </button>
                              </div>
                            </div>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                )}

                {/* í‚¤ì›Œë“œ íƒ­ */}
                {currentTab === 'keywords' && (
                  <div className="bg-white rounded-xl p-6 shadow-sm">
                    <div className="flex justify-between items-center mb-4">
                      <h2 className="font-bold">ğŸ” í‚¤ì›Œë“œ ê²€ìƒ‰ ê·œì¹™</h2>
                      <button onClick={addKeywordRule}
                        className="px-4 py-2 bg-orange-600 text-white rounded-lg hover:bg-orange-700 font-medium">
                        + í‚¤ì›Œë“œ ì¶”ê°€
                      </button>
                    </div>
                    {keywordRules.length === 0 ? (
                      <div className="text-center py-12 text-gray-400">
                        <p className="text-5xl mb-4">ğŸ”</p>
                        <p>ë“±ë¡ëœ í‚¤ì›Œë“œê°€ ì—†ìŠµë‹ˆë‹¤</p>
                      </div>
                    ) : (
                      <div className="space-y-3">
                        {keywordRules.map(rule => (
                          <div key={rule.id} className={`p-4 rounded-lg border-2 ${rule.enabled ? 'bg-orange-50 border-orange-200' : 'bg-gray-50 border-gray-200'}`}>
                            <div className="flex justify-between items-start">
                              <div>
                                <p className="font-bold">"{rule.keyword}"</p>
                                <p className="text-sm text-gray-600 mt-1">
                                  íŒ¨í„´: {rule.commentPatterns.length}ê°œ
                                  {aiCommentEnabled && <span className="ml-2 text-purple-600 font-bold">+ ğŸ¤– AI</span>}
                                </p>
                              </div>
                              <div className="flex gap-2">
                                <button onClick={() => toggleKeywordRule(rule.id)}
                                  className={`px-3 py-1 rounded-lg text-sm ${rule.enabled ? 'bg-gray-200' : 'bg-orange-600 text-white'}`}>
                                  {rule.enabled ? 'ë¹„í™œì„±í™”' : 'í™œì„±í™”'}
                                </button>
                                <button onClick={() => removeKeywordRule(rule.id)}
                                  className="px-3 py-1 bg-red-600 text-white rounded-lg text-sm">
                                  ì‚­ì œ
                                </button>
                              </div>
                            </div>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                )}

                {/* AI ì„¤ì • íƒ­ */}
                {currentTab === 'ai' && (
                  <div className="space-y-6">
                    <div className="bg-gradient-to-r from-purple-50 to-pink-50 rounded-xl p-6 border-2 border-purple-200">
                      <div className="flex justify-between items-center mb-4">
                        <div>
                          <h2 className="font-bold text-lg">ğŸ¤– AI ëŒ“ê¸€ ì‹œìŠ¤í…œ</h2>
                          <p className="text-sm text-gray-600">Claude AIê°€ ì˜ìƒì„ ë¶„ì„í•˜ì—¬ ìë™ ëŒ“ê¸€ ìƒì„±</p>
                        </div>
                        <label className="relative inline-flex items-center cursor-pointer">
                          <input type="checkbox" checked={aiCommentEnabled} 
                            onChange={e => setAiCommentEnabled(e.target.checked)} className="sr-only peer" />
                          <div className="w-16 h-8 bg-gray-300 rounded-full peer peer-checked:bg-gradient-to-r peer-checked:from-purple-600 peer-checked:to-pink-600 peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-1 after:left-[4px] after:bg-white after:rounded-full after:h-6 after:w-6 after:transition-all"></div>
                        </label>
                      </div>
                      {aiCommentEnabled && (
                        <div className="bg-white rounded-lg p-4 border-2 border-purple-300">
                          <p className="text-sm mb-2">âœ… AI ëŒ“ê¸€ í™œì„±í™”!</p>
                          <ul className="text-xs text-gray-600 space-y-1">
                            <li>â€¢ ëª¨ë“œ: {aiDemoMode ? 'ğŸ­ ë°ëª¨ (í…œí”Œë¦¿ ê¸°ë°˜)' : 'ğŸ¤– ì‹¤ì œ API (Claude AI)'}</li>
                            <li>â€¢ ì˜ìƒ ì œëª©, ì„¤ëª…, í•´ì‹œíƒœê·¸ ìë™ ë¶„ì„</li>
                            <li>â€¢ ë§¥ë½ì— ë§ëŠ” ìì—°ìŠ¤ëŸ¬ìš´ ëŒ“ê¸€ ìƒì„±</li>
                            <li>â€¢ AI ì‹¤íŒ¨ ì‹œ ìë™ìœ¼ë¡œ ê¸°ì¡´ íŒ¨í„´ ì‚¬ìš©</li>
                          </ul>
                        </div>
                      )}
                    </div>

                    <div className="bg-white rounded-xl p-6 shadow-sm">
                      <h3 className="font-bold mb-4">ğŸ¨ ëŒ“ê¸€ ìŠ¤íƒ€ì¼ ì„¤ì •</h3>
                      
                      <div className="space-y-4">
                        <div>
                          <label className="text-sm font-medium block mb-2">ë§íˆ¬/í†¤</label>
                          <div className="grid grid-cols-3 gap-3">
                            {[
                              { value: 'friendly', emoji: 'ğŸ˜Š', label: 'ì¹œê·¼í•¨' },
                              { value: 'formal', emoji: 'ğŸ©', label: 'ê²©ì‹' },
                              { value: 'humorous', emoji: 'ğŸ˜„', label: 'ìœ ë¨¸' }
                            ].map(style => (
                              <button key={style.value} onClick={() => setAiCommentStyle(style.value)}
                                className={`p-4 rounded-lg border-2 ${aiCommentStyle === style.value ? 'border-purple-500 bg-purple-50' : 'border-gray-200'}`}>
                                <p className="text-2xl mb-2">{style.emoji}</p>
                                <p className="font-bold text-sm">{style.label}</p>
                              </button>
                            ))}
                          </div>
                        </div>

                        <div>
                          <label className="text-sm font-medium block mb-2">ì´ëª¨ì§€ ì‚¬ìš©ëŸ‰</label>
                          <div className="grid grid-cols-3 gap-3">
                            {[
                              { value: 'none', label: 'âŒ ì—†ìŒ' },
                              { value: 'moderate', label: 'ğŸ˜Š ë³´í†µ' },
                              { value: 'many', label: 'ğŸ‰ ë§ì´' }
                            ].map(usage => (
                              <button key={usage.value} onClick={() => setAiEmojiUsage(usage.value)}
                                className={`p-3 rounded-lg border-2 ${aiEmojiUsage === usage.value ? 'border-blue-500 bg-blue-50' : 'border-gray-200'}`}>
                                <p className="font-bold text-sm">{usage.label}</p>
                              </button>
                            ))}
                          </div>
                        </div>

                        <div>
                          <label className="text-sm font-medium block mb-2">ëŒ“ê¸€ ê¸¸ì´</label>
                          <div className="grid grid-cols-3 gap-3">
                            {[
                              { value: 'short', label: 'ğŸ“ ì§§ê²Œ' },
                              { value: 'medium', label: 'ğŸ“ ë³´í†µ' },
                              { value: 'long', label: 'ğŸ“ ê¸¸ê²Œ' }
                            ].map(length => (
                              <button key={length.value} onClick={() => setAiCommentLength(length.value)}
                                className={`p-3 rounded-lg border-2 ${aiCommentLength === length.value ? 'border-green-500 bg-green-50' : 'border-gray-200'}`}>
                                <p className="font-bold text-sm">{length.label}</p>
                              </button>
                            ))}
                          </div>
                        </div>
                      </div>
                    </div>

                    <div className="bg-white rounded-xl p-6 shadow-sm">
                      <h3 className="font-bold mb-4">ğŸ”§ ê³ ê¸‰ AI ê¸°ëŠ¥</h3>
                      <div className="space-y-3">
                        <label className="flex items-center justify-between p-4 bg-gray-50 rounded-lg cursor-pointer">
                          <div className="flex items-center gap-3">
                            <span className="text-2xl">ğŸ–¼ï¸</span>
                            <div>
                              <p className="font-medium">ì¸ë„¤ì¼ ì´ë¯¸ì§€ ë¶„ì„</p>
                              <p className="text-xs text-gray-600">ì˜ìƒ ì¸ë„¤ì¼ì„ AIê°€ ë¶„ì„í•˜ì—¬ ëŒ“ê¸€ì— ë°˜ì˜</p>
                            </div>
                          </div>
                          <input type="checkbox" checked={aiAnalyzeImage} 
                            onChange={e => setAiAnalyzeImage(e.target.checked)} className="w-5 h-5" />
                        </label>

                        <label className="flex items-center justify-between p-4 bg-gray-50 rounded-lg cursor-pointer">
                          <div className="flex items-center gap-3">
                            <span className="text-2xl">ğŸ“Š</span>
                            <div>
                              <p className="font-medium">íŠ¸ë Œë“œ ë°˜ì˜</p>
                              <p className="text-xs text-gray-600">2025ë…„ ìµœì‹  íŠ¸ë Œë“œì™€ ìœ í–‰ì–´ë¥¼ ëŒ“ê¸€ì— ë°˜ì˜</p>
                            </div>
                          </div>
                          <input type="checkbox" checked={aiTrendAware} 
                            onChange={e => setAiTrendAware(e.target.checked)} className="w-5 h-5" />
                        </label>

                        <div>
                          <label className="text-sm font-medium block mb-2">ì»¤ìŠ¤í…€ í”„ë¡¬í”„íŠ¸ (ì„ íƒì‚¬í•­)</label>
                          <textarea 
                            value={aiCustomPrompt}
                            onChange={e => setAiCustomPrompt(e.target.value)}
                            placeholder="ì˜ˆ: í•­ìƒ 'ê°ì‚¬í•©ë‹ˆë‹¤'ë¡œ ëë‚´ì£¼ì„¸ìš”"
                            className="w-full border rounded-lg px-3 py-2 text-sm h-20 resize-none"
                          />
                          <p className="text-xs text-gray-500 mt-1">AIì—ê²Œ ì¶”ê°€ë¡œ ì „ë‹¬í•  ì§€ì¹¨</p>
                        </div>
                      </div>
                    </div>
                  </div>
                )}

                {/* ìµœì í™” íƒ­ */}
                {currentTab === 'optimization' && (
                  <div className="space-y-6">
                    <div className="bg-white rounded-xl p-6 shadow-sm">
                      <h2 className="font-bold mb-4 text-lg">ğŸš€ ìµœì í™” ì„¤ì •</h2>
                      
                      <div className="space-y-6">
                        <div className="p-5 bg-green-50 rounded-lg border-2 border-green-200">
                          <div className="flex items-center justify-between mb-4">
                            <div className="flex items-center gap-3">
                              <span className="text-3xl">ğŸ’¾</span>
                              <div>
                                <h3 className="font-bold text-lg">ìŠ¤ë§ˆíŠ¸ ìºì‹± ì‹œìŠ¤í…œ</h3>
                                <p className="text-sm text-gray-600">API ìš”ì²­ì„ ìºì‹œì— ì €ì¥í•˜ì—¬ 70-80% ì ˆì•½</p>
                              </div>
                            </div>
                            <label className="relative inline-flex items-center cursor-pointer">
                              <input type="checkbox" checked={cacheEnabled} 
                                onChange={e => setCacheEnabled(e.target.checked)} className="sr-only peer" />
                              <div className="w-14 h-7 bg-gray-300 rounded-full peer peer-checked:bg-green-600 peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-0.5 after:left-[4px] after:bg-white after:rounded-full after:h-6 after:w-6 after:transition-all"></div>
                            </label>
                          </div>
                          {cacheEnabled && (
                            <div className="space-y-3 pl-12">
                              <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
                                <div>
                                  <label className="text-sm font-medium block mb-1">ì±„ë„ ì •ë³´ TTL (ë¶„)</label>
                                  <input type="number" value={cacheTTL.channelInfo} 
                                    onChange={e => setCacheTTL({...cacheTTL, channelInfo: parseInt(e.target.value) || 1440})}
                                    className="w-full border rounded-lg px-3 py-2 text-sm" min="1" />
                                </div>
                                <div>
                                  <label className="text-sm font-medium block mb-1">ì˜ìƒ ëª©ë¡ TTL (ë¶„)</label>
                                  <input type="number" value={cacheTTL.videoList} 
                                    onChange={e => setCacheTTL({...cacheTTL, videoList: parseInt(e.target.value) || 5})}
                                    className="w-full border rounded-lg px-3 py-2 text-sm" min="1" />
                                </div>
                                <div>
                                  <label className="text-sm font-medium block mb-1">ì˜ìƒ ìƒì„¸ TTL (ë¶„)</label>
                                  <input type="number" value={cacheTTL.videoDetails} 
                                    onChange={e => setCacheTTL({...cacheTTL, videoDetails: parseInt(e.target.value) || 60})}
                                    className="w-full border rounded-lg px-3 py-2 text-sm" min="1" />
                                </div>
                              </div>
                              <div className="flex gap-2">
                                <div className="flex-1 bg-white p-3 rounded-lg border">
                                  <p className="text-xs text-gray-600">ìºì‹œ íˆíŠ¸ìœ¨</p>
                                  <p className="text-xl font-bold text-green-600">{cacheStats.hitRate}%</p>
                                </div>
                                <div className="flex-1 bg-white p-3 rounded-lg border">
                                  <p className="text-xs text-gray-600">ì´ ìš”ì²­</p>
                                  <p className="text-xl font-bold text-blue-600">{cacheStats.requests}</p>
                                </div>
                                <button onClick={clearCache}
                                  className="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 text-sm">
                                  ìºì‹œ ì´ˆê¸°í™”
                                </button>
                              </div>
                            </div>
                          )}
                        </div>

                        <div className="p-5 bg-blue-50 rounded-lg border-2 border-blue-200">
                          <div className="flex items-center justify-between mb-4">
                            <div className="flex items-center gap-3">
                              <span className="text-3xl">âš¡</span>
                              <div>
                                <h3 className="font-bold text-lg">ì¦ë¶„ ì²´í¬ ì‹œìŠ¤í…œ</h3>
                                <p className="text-sm text-gray-600">ETagì™€ Last-Modifiedë¡œ 85-90% ì ˆì•½</p>
                              </div>
                            </div>
                            <label className="relative inline-flex items-center cursor-pointer">
                              <input type="checkbox" checked={incrementalEnabled} 
                                onChange={e => setIncrementalEnabled(e.target.checked)} className="sr-only peer" />
                              <div className="w-14 h-7 bg-gray-300 rounded-full peer peer-checked:bg-blue-600 peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-0.5 after:left-[4px] after:bg-white after:rounded-full after:h-6 after:w-6 after:transition-all"></div>
                            </label>
                          </div>
                          {incrementalEnabled && (
                            <div className="space-y-3 pl-12">
                              <div>
                                <label className="text-sm font-medium block mb-1">ì „ì²´ ê²€ìƒ‰ ìµœëŒ€ ê°„ê²© (ë¶„)</label>
                                <input type="number" value={fullSearchMaxInterval} 
                                  onChange={e => setFullSearchMaxInterval(parseInt(e.target.value) || 60)}
                                  className="w-full border rounded-lg px-3 py-2 text-sm max-w-xs" min="5" />
                              </div>
                              <button onClick={resetIncrementalState}
                                className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 text-sm">
                                ì¦ë¶„ ìƒíƒœ ì´ˆê¸°í™”
                              </button>
                            </div>
                          )}
                        </div>

                        <div className="p-5 bg-purple-50 rounded-lg border-2 border-purple-200">
                          <div className="flex items-center justify-between mb-4">
                            <div className="flex items-center gap-3">
                              <span className="text-3xl">ğŸ¯</span>
                              <div>
                                <h3 className="font-bold text-lg">HEAD ìš”ì²­ ì²´í¬</h3>
                                <p className="text-sm text-gray-600">GET ì „ì— HEADë¡œ ë³€ê²½ í™•ì¸, 95-98% ì ˆì•½</p>
                              </div>
                            </div>
                            <label className="relative inline-flex items-center cursor-pointer">
                              <input type="checkbox" checked={headCheckEnabled} 
                                onChange={e => setHeadCheckEnabled(e.target.checked)} className="sr-only peer" />
                              <div className="w-14 h-7 bg-gray-300 rounded-full peer peer-checked:bg-purple-600 peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-0.5 after:left-[4px] after:bg-white after:rounded-full after:h-6 after:w-6 after:transition-all"></div>
                            </label>
                          </div>
                          {headCheckEnabled && (
                            <div className="pl-12">
                              <label className="text-sm font-medium block mb-1">HEAD ì²´í¬ ê°„ê²© (ë¶„)</label>
                              <input type="number" value={headCheckInterval} 
                                onChange={e => setHeadCheckInterval(parseInt(e.target.value) || 5)}
                                className="w-full border rounded-lg px-3 py-2 text-sm max-w-xs" min="1" />
                            </div>
                          )}
                        </div>
                      </div>
                    </div>
                  </div>
                )}

                {/* ëŒ“ê¸€ íƒ­ */}
                {currentTab === 'comments' && (
                  <div className="bg-white rounded-xl p-6 shadow-sm">
                    <h2 className="font-bold mb-4">ğŸ’¬ ì‘ì„±í•œ ëŒ“ê¸€ ({comments.length})</h2>
                    {comments.length === 0 ? (
                      <div className="text-center py-12 text-gray-400">
                        <p className="text-5xl mb-4">ğŸ’¬</p>
                        <p>ì‘ì„±í•œ ëŒ“ê¸€ì´ ì—†ìŠµë‹ˆë‹¤</p>
                      </div>
                    ) : (
                      <div className="space-y-3">
                        {comments.map(comment => (
                          <div key={comment.id} className={`p-4 rounded-lg border-2 ${comment.isAI ? 'bg-purple-50 border-purple-200' : 'bg-blue-50 border-blue-200'}`}>
                            <div className="flex justify-between items-start mb-2">
                              <p className="text-gray-800 flex-1">"{comment.text}"</p>
                              {comment.isAI && (
                                <span className="ml-2 text-xs bg-gradient-to-r from-purple-600 to-pink-600 text-white px-2 py-1 rounded-full font-bold">
                                  ğŸ¤– AI{aiDemoMode ? '(ë°ëª¨)' : ''}
                                </span>
                              )}
                              {comment.posted && (
                                <span className="ml-2 text-xs bg-green-600 text-white px-2 py-1 rounded-full">
                                  âœ“ ì‘ì„±ë¨
                                </span>
                              )}
                            </div>
                            <div className="flex justify-between items-center text-sm">
                              <div>
                                <p className="text-gray-600">{comment.video}</p>
                                <p className="text-xs text-gray-500 mt-1">{comment.source} â€¢ {comment.time}</p>
                              </div>
                              <div className="flex gap-2">
                                <a href={comment.commentLink} target="_blank" rel="noopener noreferrer"
                                  className="px-3 py-1 bg-blue-600 text-white rounded-lg hover:bg-blue-700 text-xs">
                                  ëŒ“ê¸€ ë³´ê¸°
                                </a>
                                <a href={comment.videoLink} target="_blank" rel="noopener noreferrer"
                                  className="px-3 py-1 bg-red-600 text-white rounded-lg hover:bg-red-700 text-xs">
                                  ì˜ìƒ ë³´ê¸°
                                </a>
                              </div>
                            </div>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                )}

                {/* ë¡œê·¸ íƒ­ */}
                {currentTab === 'logs' && (
                  <div className="bg-white rounded-xl p-6 shadow-sm">
                    <div className="flex justify-between items-center mb-4">
                      <h2 className="font-bold">ğŸ“‹ í™œë™ ë¡œê·¸ ({logs.length})</h2>
                      <button onClick={() => { setLogs([]); addLog('ë¡œê·¸ ì´ˆê¸°í™”', 'info'); }}
                        className="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 text-sm">
                        ë¡œê·¸ ì§€ìš°ê¸°
                      </button>
                    </div>
                    {logs.length === 0 ? (
                      <div className="text-center py-12 text-gray-400">
                        <p className="text-5xl mb-4">ğŸ“‹</p>
                        <p>ë¡œê·¸ê°€ ì—†ìŠµë‹ˆë‹¤</p>
                      </div>
                    ) : (
                      <div className="space-y-2 max-h-[600px] overflow-y-auto">
                        {logs.map(log => (
                          <div key={log.id} className={`p-3 rounded-lg text-sm ${
                            log.type === 'success' ? 'bg-green-50 text-green-800' :
                            log.type === 'warning' ? 'bg-yellow-50 text-yellow-800' :
                            log.type === 'error' ? 'bg-red-50 text-red-800' :
                            'bg-gray-50 text-gray-800'
                          }`}>
                            <span className="text-xs text-gray-500 mr-2">[{log.time}]</span>
                            {log.msg}
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                )}
